# vim: set ft=yaml:
# yaml-language-server: $schema=values.schema.json

# @schema
# additionalProperties: true
# @schema
image:
  # @schema
  # type: string
  # @schema
  # -- The container image repository.
  repository: timmi6790/netcup-offer-bot

  # @schema
  # type: string
  # @schema
  # -- The container image tag.
  tag: v1.5.1@sha256:b8002f21875b5b6fe323a9684139e0cb4f856d89edb3d3c319130a573e8de97c

  # Valid options are: Always, IfNotPresent, Never
  # @schema
  # enum: [Always, IfNotPresent, Never]
  # @schema
  # -- The image pull policy.
  pullPolicy: IfNotPresent

# @schema
# type: array
# @schema
# -- Optional image pull secrets for private registries
imagePullSecrets: []

# @schema
# additionalProperties: true
# @schema
env:
  # @schema
  # type: string
  # @schema
  # -- Sentry DSN for error tracking. Leave empty to disable.
  sentryDns: ""

  # @schema
  # type: string
  # @schema
  # -- Webhook URL to send updates or notifications.
  webHook: ""

  # @schema
  # type: integer
  # minimum: 1
  # @schema
  # -- Interval in seconds between offer checks.
  checkInterval: 180

  # @schema
  # enum: [debug, info, warn, error]
  # @schema
  # -- Log level for the application.
  logLevel: info

# @schema
# additionalProperties: true
# @schema
podSecurityContext:
  # @schema
  # type: boolean
  # @schema
  # -- Run pod as non-root user
  runAsNonRoot: true

  # @schema
  # type: integer
  # @schema
  # -- User ID to run as
  runAsUser: 1000

  # @schema
  # type: integer
  # @schema
  # -- Group ID for file system access
  fsGroup: 1000

# @schema
# additionalProperties: true
# @schema
securityContext:
  # @schema
  # type: boolean
  # @schema
  # -- Allow privilege escalation
  allowPrivilegeEscalation: false

  # @schema
  # additionalProperties: true
  # @schema
  capabilities:
    # @schema
    # type: array
    # @schema
    # -- Linux capabilities to drop
    drop:
      - ALL

  # @schema
  # type: boolean
  # @schema
  # -- Mount root filesystem as read-only
  readOnlyRootFilesystem: true

# @schema
# additionalProperties: true
# @schema
serviceAccount:
  # @schema
  # type: boolean
  # @schema
  # -- Whether to create a dedicated service account
  create: true

  # @schema
  # type: object
  # @schema
  # -- Additional annotations for the service account
  annotations: {}

  # @schema
  # type: string
  # @schema
  # -- Custom service account name (auto-generated if empty)
  name: ""

  # @schema
  # type: boolean
  # @schema
  # -- Whether to automount the service account token
  automountToken: false

# @schema
# type: array
# @schema
# -- Pod topology spread constraints for availability
topologySpreadConstraints: []

# @schema
# type: string
# @schema
# -- Optional Kubernetes PriorityClass name
priorityClassName: ""

# @schema
# additionalProperties: true
# @schema
persistence:
  # @schema
  # additionalProperties: true
  # @schema
  # -- Configuration for persistent data storage.
  data:
    # @schema
    # enum: [ReadWriteOnce, ReadOnlyMany, ReadWriteMany]
    # @schema
    # -- The access mode for the persistent volume.
    accessMode: ReadWriteOnce

    # @schema
    # type: string
    # @schema
    # -- The storage size requested for the volume.
    size: 10Mi

# @schema
# additionalProperties: true
# @schema
metrics:
  # @schema
  # type: boolean
  # @schema
  # -- Enable Prometheus metrics endpoint.
  enabled: false

  # @schema
  # type: integer
  # @schema
  # -- Port to expose metrics on.
  port: 9184

  # @schema
  # additionalProperties: true
  # @schema
  # -- ServiceMonitor configuration for Prometheus Operator integration.
  serviceMonitor:
    # @schema
    # type: string
    # @schema
    # -- Metrics scrape interval (e.g., 1m, 30s).
    interval: 1m

    # @schema
    # type: string
    # @schema
    # -- Namespace where monitoring tools are running
    namespace: monitoring

    # @schema
    # type: string
    # @schema
    # -- Timeout for metrics scraping (e.g., 30s).
    scrapeTimeout: 30s

# @schema
# additionalProperties: true
# @schema
resources:
  # @schema
  # additionalProperties: true
  # @schema
  # -- Resource limits for the container.
  limits:
    # @schema
    # type: string
    # @schema
    # -- Maximum allowed memory usage.
    memory: 20Mi

  # @schema
  # additionalProperties: true
  # @schema
  # -- Resource requests for the container.
  requests:
    # @schema
    # type: string
    # @schema
    # -- Minimum guaranteed memory allocation.
    memory: 15Mi

# @schema
# additionalProperties: true
# @schema
# -- Network policy configuration
networkPolicy:
  # @schema
  # type: boolean
  # @schema
  # -- Enable network policies
  enabled: false

  # @schema
  # additionalProperties: true
  # @schema
  # -- Ingress configuration
  ingress:
    # @schema
    # type: boolean
    # @schema
    # -- Enable ingress rules
    enabled: true

    # @schema
    # additionalProperties: true
    # @schema
    # -- Monitoring configuration for ingress
    monitoring:
      # @schema
      # type: boolean
      # @schema
      # -- Allow ingress from monitoring namespace
      enabled: true

      # @schema
      # type: string
      # @schema
      # -- Namespace where monitoring tools are running
      namespace: monitoring

    # @schema
    # additionalProperties: true
    # @schema
    # -- Ingress Controller configuration
    controller:
      # @schema
      # type: boolean
      # @schema
      # -- Allow ingress from Ingress Controller
      enabled: true

      # @schema
      # type: string
      # @schema
      # -- Namespace where Ingress Controller is running (default: traefik)
      namespace: traefik

      # @schema
      # type: object
      # @schema
      # -- Pod selector for Ingress Controller (default: Traefik label)
      selector:
        app.kubernetes.io/name: traefik

    # @schema
    # type: array
    # items:
    #   type: object
    #   properties:
    #     ports:
    #       type: array
    #       items:
    #         $ref: "#/definitions/networkPolicy.json#/networkPolicyPort"
    #     from:
    #       type: array
    #       items:
    #         $ref: "#/definitions/networkPolicy.json#/networkPolicyPeer"
    # @schema
    # -- Custom ingress rules
    customRules: []

  # @schema
  # additionalProperties: true
  # @schema
  # -- Egress configuration
  egress:
    # @schema
    # type: boolean
    # @schema
    # -- Enable egress rules
    enabled: true

    # @schema
    # additionalProperties: true
    # @schema
    # -- DNS configuration for egress
    dns:
      # @schema
      # type: boolean
      # @schema
      # -- Allow egress to DNS
      enabled: true

    # @schema
    # additionalProperties: true
    # @schema
    # -- HTTP configuration for egress
    http:
      # @schema
      # type: boolean
      # @schema
      # -- Allow egress to HTTP (TCP/80)
      enabled: false

    # @schema
    # additionalProperties: true
    # @schema
    # -- HTTPS configuration for egress
    https:
      # @schema
      # type: boolean
      # @schema
      # -- Allow egress to HTTPS (TCP/443)
      enabled: true

    # @schema
    # additionalProperties: true
    # @schema
    # -- Sentry configuration for egress
    sentry:
      # @schema
      # type: boolean
      # @schema
      # -- Allow egress to Sentry (HTTPS)
      enabled: false

    # @schema
    # type: array
    # items:
    #   type: object
    #   properties:
    #     ports:
    #       type: array
    #       items:
    #         $ref: "#/definitions/networkPolicy.json#/networkPolicyPort"
    #     to:
    #       type: array
    #       items:
    #         $ref: "#/definitions/networkPolicy.json#/networkPolicyPeer"
    # @schema
    # -- Custom egress rules
    customRules: []

